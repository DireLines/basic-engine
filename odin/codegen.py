# codegen.py
# searches for .object files, which are yaml specifications of GameObject instances,
# and turns them into C++ implementations in a file called GameObjects.h
from pathlib import Path
import os
try:
    import yaml
except ImportError:
    print("you are missing pyyaml")
    print("pip3 install pyyaml --user")
    exit()

#helpers
class NameGenerator:
    def __init__(self,variable_name):
        self.id = 0
        self.variable_name = variable_name
    def next(self):
        self.id += 1
        return self.variable_name + str(self.id)
variable_name_generator = {}

def variable_name(var_type):
    if var_type not in variable_name_generator:
        variable_name_generator[var_type] = NameGenerator(var_type)
    return variable_name_generator[var_type].next()

# filename('/path/to/cool-file.txt') = 'cool-file'
def filename(filepath):
    return os.path.splitext(os.path.basename(filepath))[0]

def all_files_of_types(filetypes, path=''):
    result = []
    for filetype in filetypes:
        result.extend(Path(path).rglob('*.'+filetype))
    return result

object_types_declared = set()

# construct an odin assignment statement
# assign(['steve','favorite_color'],'green') = 'steve.favorite_color = green'
def assign(base_path,value):
    #some special cases for literals
    if(type(value) == str):
        value = '"' + value + '"'
    if(type(value) == bool):
        value = str(value).lower()
    if(type(value) == dict and 'code' in value):
        value = value['code']
    base_path = '.'.join(base_path)
    return f'{base_path} = {str(value)}\n'

basic_components = ["transform","rigidbody","collider","sprite","animation"]
#for one component, get component bits to set
def get_component_set(component):
    components = []
    if component.lower() in basic_components:
        components.append(component.capitalize())
    else:
        components.append('Script')
    return set(components)
#for all components, get component bits to set
def get_total_component_set(component_names):
    component_set = set()
    for component in component_names:
        component_set = component_set.union(get_component_set(component))
    return component_set
def set_to_enum_literal(component_set):
    result = "{ "
    variants = []
    for component in component_set:
        variants.append("." + component)
    result += ", ".join(variants)
    result += " }"
    return result
#is component in main package, or else is it in its own package?
def in_main_package(component_name):
    if component_name.lower() in basic_components:
        return False
    return True
#get code for initializing the components to defaults in the struct literal
def init_components(components):
    component_names = []
    for component in components:
        if type(component) == str:
            component_names.append(component)
        if type(component) == dict:
            component_names.extend(component.keys())
    result = ""
    component_set = set_to_enum_literal(get_total_component_set(component_names))
    result += f"component_set = {component_set},\n"
    for component in component_names:
        pkg_dot = ""
        if not in_main_package(component):
            packages_needed.append(f'import "{component}"')
            pkg_dot = component + "."
        result += f"        {component} = {pkg_dot}default_{component}(),\n"
    return result

#get code for setting fields 
def set_fields(components,owner_name):
    result = ""
    for component in components:
        if type(component) != dict:
            continue
        assert(len(component.keys()) == 1)
        component_name = list(component.keys())[0]
        values = component[component_name]
        for k in values:
            v = values[k]
            result += "    " + assign([owner_name,component_name,k],v)
    return result

packages_needed = []
constructors_header = """package main
// AUTOGENERATED object constructor procs from .object files
import "core:math/rand"
//component_imports
""" 
object_types = ""
constructors = ""
obj_filenames = all_files_of_types(['object','scene'])
for obj_filename in sorted(obj_filenames):
    with open(obj_filename, 'r') as obj_file:
        object_type = filename(obj_filename)
        object_types_declared.add(object_type)
        yaml_contents = yaml.safe_load(obj_file.read())
        init_components_code = init_components(yaml_contents)
        set_fields_code = set_fields(yaml_contents, 'obj')
        constructor_code = """
example :: proc() -> GameObject {
    obj := GameObject {
        //init-components
    }
//set-fields
    return obj
}
        """.replace("example",object_type)\
            .replace("//init-components",init_components_code.rstrip())\
            .replace('//set-fields',set_fields_code.rstrip())
        constructors += constructor_code.rstrip() + '\n'
package_imports = "\n".join(set(packages_needed))
constructors_header = constructors_header.replace("//component_imports",package_imports)
constructor_code = constructors_header + constructors
output_directory = '.'
if not os.path.exists(output_directory):
    os.makedirs(output_directory)
constructor_filepath = output_directory + '/' + 'generated_objects.odin'
if(os.path.exists(constructor_filepath) and open(constructor_filepath,'r').read() == constructor_code):
    exit() #if generated code was unchanged, don't make the compiler think it was (for incremental compilation)
constructor_file = open(constructor_filepath, 'w')
constructor_file.write(constructor_code)
# print(constructor_code)

